<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.17"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>IOH: ioh::logger::Levels Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">IOH
   &#160;<span id="projectnumber">0.0.0.1</span>
   </div>
   <div id="projectbrief">Experimentation procedure for Iterative Optimization Heuristics</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.17 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('classioh_1_1logger_1_1_levels.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="#pro-attribs">Protected Attributes</a> &#124;
<a href="classioh_1_1logger_1_1_levels-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">ioh::logger::Levels Class Reference<div class="ingroups"><a class="el" href="group___features.html">Features</a> &raquo; <a class="el" href="group___loggers.html">Loggers</a> &raquo; <a class="el" href="group___e_a_f.html">Empirical Attainment Function</a><a class="el" href="group___features.html">Features</a> &raquo;  &#124; <a class="el" href="group___loggers.html">Loggers</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p>A logger that store the 2D quality/time attainment fronts for each runs.  
 <a href="classioh_1_1logger_1_1_levels.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="eaf_8hpp_source.html">ioh/logger/eaf.hpp</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:ab6a69ec6aa4c7105df889191ea68edd2"><td class="memItemLeft" align="right" valign="top"><a id="ab6a69ec6aa4c7105df889191ea68edd2"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classioh_1_1logger_1_1_levels.html#ab6a69ec6aa4c7105df889191ea68edd2">Type</a> = std::map&lt; size_t, eaf::Front &gt;</td></tr>
<tr class="memdesc:ab6a69ec6aa4c7105df889191ea68edd2"><td class="mdescLeft">&#160;</td><td class="mdescRight">The type returned by the call interface. <br /></td></tr>
<tr class="separator:ab6a69ec6aa4c7105df889191ea68edd2"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a4d9d7b811e3dfa2054a2313a19590c34"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classioh_1_1logger_1_1_levels.html#a4d9d7b811e3dfa2054a2313a19590c34">Levels</a> (const <a class="el" href="namespaceioh_1_1common.html#a10ff539dd4ec41851f2c305aac9e3c4b">common::OptimizationType</a> optim_type, std::vector&lt; size_t &gt; attainment_levels={})</td></tr>
<tr class="memdesc:a4d9d7b811e3dfa2054a2313a19590c34"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor.  <a href="classioh_1_1logger_1_1_levels.html#a4d9d7b811e3dfa2054a2313a19590c34">More...</a><br /></td></tr>
<tr class="separator:a4d9d7b811e3dfa2054a2313a19590c34"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a30b38e7cfe33c690630b235cfbeb4b96"><td class="memItemLeft" align="right" valign="top"><a id="a30b38e7cfe33c690630b235cfbeb4b96"></a>
<a class="el" href="classioh_1_1logger_1_1_levels.html#ab6a69ec6aa4c7105df889191ea68edd2">Type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classioh_1_1logger_1_1_levels.html#a30b38e7cfe33c690630b235cfbeb4b96">operator()</a> (const EAF &amp;logger)</td></tr>
<tr class="memdesc:a30b38e7cfe33c690630b235cfbeb4b96"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extract the runs from the logger and computes the attainment levelsets. <br /></td></tr>
<tr class="separator:a30b38e7cfe33c690630b235cfbeb4b96"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:acaea09bd43bc3d493a4ca477a1e11dc7"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classioh_1_1logger_1_1_levels.html#acaea09bd43bc3d493a4ca477a1e11dc7">is_better</a> (const double q1, const double q2)</td></tr>
<tr class="memdesc:acaea09bd43bc3d493a4ca477a1e11dc7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compare two objective function values.  <a href="classioh_1_1logger_1_1_levels.html#acaea09bd43bc3d493a4ca477a1e11dc7">More...</a><br /></td></tr>
<tr class="separator:acaea09bd43bc3d493a4ca477a1e11dc7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee07f212aaf68e27c4658e63afd123a1"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classioh_1_1logger_1_1_levels.html#aee07f212aaf68e27c4658e63afd123a1">is_better_or_eq</a> (const double q1, const double q2)</td></tr>
<tr class="memdesc:aee07f212aaf68e27c4658e63afd123a1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compare two objective function values.  <a href="classioh_1_1logger_1_1_levels.html#aee07f212aaf68e27c4658e63afd123a1">More...</a><br /></td></tr>
<tr class="separator:aee07f212aaf68e27c4658e63afd123a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr class="memitem:a8b4ebf058da980c8db8934d49072a263"><td class="memItemLeft" align="right" valign="top"><a id="a8b4ebf058da980c8db8934d49072a263"></a>
std::vector&lt; size_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classioh_1_1logger_1_1_levels.html#a8b4ebf058da980c8db8934d49072a263">_attlevels</a></td></tr>
<tr class="memdesc:a8b4ebf058da980c8db8934d49072a263"><td class="mdescLeft">&#160;</td><td class="mdescRight">Asked attainment levels indices. <br /></td></tr>
<tr class="separator:a8b4ebf058da980c8db8934d49072a263"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a65f63d9f7c509690659f4defb408dbfa"><td class="memItemLeft" align="right" valign="top"><a id="a65f63d9f7c509690659f4defb408dbfa"></a>
const <a class="el" href="classioh_1_1common_1_1_f_optimization_type.html">common::FOptimizationType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classioh_1_1logger_1_1_levels.html#a65f63d9f7c509690659f4defb408dbfa">_optim_type</a></td></tr>
<tr class="memdesc:a65f63d9f7c509690659f4defb408dbfa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Whether we minimize or maximize. <br /></td></tr>
<tr class="separator:a65f63d9f7c509690659f4defb408dbfa"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>A logger that store the 2D quality/time attainment fronts for each runs. </p>
<p>An attainment front is the set of Pareto-optimal quality/time targets attained during a given run. That is, a set of points that are non-dominated: either the quality or the time is better than the other points in set.</p>
<p>The set of attainment fronts samples a 2D distribution of probability, which is a generalization of performance distribution of the algorithm(s) observed by the logger(s). Taking the convex subset of the projections of the non-dominated points for a given quality target would recover the sample of the expected runtime empirical cumulative density function.</p>
<p>The underlying empirical attainment function levelsets can be computed with stat::Levels.</p>
<p>More information in the following publication: </p><div class="fragment"><div class="line">        @incollection{LopPaqStu09emaa,</div>
<div class="line">          editor = { Thomas Bartz-Beielstein  and  Marco Chiarandini  and  Lu{\<span class="stringliteral">&#39;\i}s Paquete  and  Mike Preuss },</span></div>
<div class="line"><span class="stringliteral">          year = 2010,</span></div>
<div class="line"><span class="stringliteral">          address = {Berlin, Germany},</span></div>
<div class="line"><span class="stringliteral">          publisher = {Springer},</span></div>
<div class="line"><span class="stringliteral">          booktitle = {Experimental Methods for the Analysis of Optimization Algorithms},</span></div>
<div class="line"><span class="stringliteral">          author = { Manuel L{\&#39;o}pez-Ib{\&#39;a}{\~n}ez  and  Lu{\&#39;\i}s Paquete  and  Thomas St{\&quot;u}tzle },</span></div>
<div class="line"><span class="stringliteral">          title = {Exploratory Analysis of Stochastic Local Search Algorithms in Biobjective Optimization},</span></div>
<div class="line"><span class="stringliteral">          pages = {209--222},</span></div>
<div class="line"><span class="stringliteral">          doi = {10.1007/978-3-642-02538-9_9},</span></div>
<div class="line"><span class="stringliteral">          abstract = {This chapter introduces two Perl programs that</span></div>
<div class="line"><span class="stringliteral">                      implement graphical tools for exploring the performance of stochastic local search algorithms</span></div>
<div class="line"><span class="stringliteral">                      for biobjective optimization problems. These tools are based on the concept of the empirical attainment</span></div>
<div class="line"><span class="stringliteral">                      function (EAF), which describes the probabilistic distribution of the outcomes obtained by a</span></div>
<div class="line"><span class="stringliteral">                      stochastic algorithm in the objective space. In particular, we consider the visualization of</span></div>
<div class="line"><span class="stringliteral">                      attainment surfaces and differences between the first-order EAFs of the outcomes of two</span></div>
<div class="line"><span class="stringliteral">                      algorithms. This visualization allows us to identify certain algorithmic behaviors in a graphical way.</span></div>
<div class="line"><span class="stringliteral">                      We explain the use of these visualization tools and illustrate them with examples arising from</span></div>
<div class="line"><span class="stringliteral">                      practice.}</span></div>
<div class="line"><span class="stringliteral">        }</span></div>
<div class="line"><span class="stringliteral">      /</span></div>
<div class="line"><span class="stringliteral">    class EAF : public Logger {</span></div>
<div class="line"><span class="stringliteral">    public:</span></div>
<div class="line"><span class="stringliteral">        using Runs       = std::map&lt;size_t     , eaf::Front&gt;;</span></div>
<div class="line"><span class="stringliteral">        using Instances  = std::map&lt;int        , Runs      &gt;;</span></div>
<div class="line"><span class="stringliteral">        using Dimensions = std::map&lt;int        , Instances &gt;;</span></div>
<div class="line"><span class="stringliteral">        using Problems   = std::map&lt;int        , Dimensions&gt;;</span></div>
<div class="line"><span class="stringliteral">        using Suites     = std::map&lt;std::string, Problems  &gt;;</span></div>
<div class="line"><span class="stringliteral">        inline static const std::string default_suite = &quot;None&quot;;</span></div>
<div class="line"><span class="stringliteral"></span> </div>
<div class="line"><span class="stringliteral">        [[nodiscard]] const Suites&amp; data() const {return _data;}</span></div>
<div class="line"><span class="stringliteral"></span> </div>
<div class="line"><span class="stringliteral">        struct Cursor {</span></div>
<div class="line"><span class="stringliteral">            std::string suite;</span></div>
<div class="line"><span class="stringliteral">            int pb;</span></div>
<div class="line"><span class="stringliteral">            int dim;</span></div>
<div class="line"><span class="stringliteral">            int ins;</span></div>
<div class="line"><span class="stringliteral">            size_t run;</span></div>
<div class="line"><span class="stringliteral">            Cursor(std::string suite_name = default_suite,</span></div>
<div class="line"><span class="stringliteral">                    int problem_id = 0,</span></div>
<div class="line"><span class="stringliteral">                    int dimension = 0,</span></div>
<div class="line"><span class="stringliteral">                    int instance_id = 0,</span></div>
<div class="line"><span class="stringliteral">                    size_t run_id = 0)</span></div>
<div class="line"><span class="stringliteral">            : suite(suite_name),</span></div>
<div class="line"><span class="stringliteral">              pb(problem_id),</span></div>
<div class="line"><span class="stringliteral">              dim(dimension),</span></div>
<div class="line"><span class="stringliteral">              ins(instance_id),</span></div>
<div class="line"><span class="stringliteral">              run(run_id)</span></div>
<div class="line"><span class="stringliteral">            { }</span></div>
<div class="line"><span class="stringliteral">        };</span></div>
<div class="line"><span class="stringliteral"></span> </div>
<div class="line"><span class="stringliteral">        [[nodiscard]] const eaf::Front&amp; data(const Cursor cur) const</span></div>
<div class="line"><span class="stringliteral">        {</span></div>
<div class="line"><span class="stringliteral">#ifndef NDEBUG</span></div>
<div class="line"><span class="stringliteral">            assert(_data.count(cur.suite) &gt; 0);</span></div>
<div class="line"><span class="stringliteral">            assert(   _data.at(cur.suite).count(cur.pb) &gt; 0);</span></div>
<div class="line"><span class="stringliteral">            assert(   _data.at(cur.suite)   .at(cur.pb).count(cur.dim) &gt; 0);</span></div>
<div class="line"><span class="stringliteral">            assert(   _data.at(cur.suite)   .at(cur.pb)   .at(cur.dim).count(cur.ins) &gt; 0);</span></div>
<div class="line"><span class="stringliteral">            assert(   _data.at(cur.suite)   .at(cur.pb)   .at(cur.dim)   .at(cur.ins).count(cur.run) &gt; 0);</span></div>
<div class="line"><span class="stringliteral">#endif</span></div>
<div class="line"><span class="stringliteral">            return _data.at(cur.suite).at(cur.pb).at(cur.dim).at(cur.ins).at(cur.run);</span></div>
<div class="line"><span class="stringliteral"></span> </div>
<div class="line"><span class="stringliteral">        }</span></div>
<div class="line"><span class="stringliteral"></span> </div>
<div class="line"><span class="stringliteral">    public:</span></div>
<div class="line"><span class="stringliteral">        EAF() : Logger(), _has_problem_type(false)</span></div>
<div class="line"><span class="stringliteral">        {</span></div>
<div class="line"><span class="stringliteral">            // Do not use the Logger&#39;</span>s constructor, to avoid passing references to uninitialized members.</div>
<div class="line">            <span class="comment">// /!\ needed by the algorithm, do not change unless you know what you&#39;re doing.</span></div>
<div class="line">            triggers_.insert(std::ref(_on_improvement));</div>
<div class="line">            <span class="comment">// /!\ needed by the related eaf::stat::* classes.</span></div>
<div class="line">            properties_.insert_or_assign(_transformed_y_best.name(), _transformed_y_best);</div>
<div class="line">            properties_.insert_or_assign(       _evaluations.name(), _evaluations);</div>
<div class="line">        }</div>
<div class="line"> </div>
<div class="line">        <span class="keyword">virtual</span> <span class="keywordtype">void</span> attach_suite(<span class="keyword">const</span> std::string&amp; suite_name)<span class="keyword"> override</span></div>
<div class="line"><span class="keyword">        </span>{</div>
<div class="line">            _current.suite = suite_name;</div>
<div class="line">        }</div>
<div class="line"> </div>
<div class="line">        <span class="keywordtype">void</span> attach_problem(<span class="keyword">const</span> problem::MetaData&amp; problem)<span class="keyword"> override</span></div>
<div class="line"><span class="keyword">        </span>{</div>
<div class="line">            <a class="code" href="classioh_1_1_logger.html#a2be703d7bdcbdbfc636063a20d3eaa8e">Logger::attach_problem</a>(problem);</div>
<div class="line"> </div>
<div class="line">            _current.pb  = problem.problem_id;</div>
<div class="line">            _current.dim = problem.n_variables;</div>
<div class="line">            _current.ins = problem.instance;</div>
<div class="line">            </div>
<div class="line">            <span class="keyword">const</span> Runs&amp; runs  = _data[_current.suite][_current.pb][_current.dim][_current.ins];</div>
<div class="line">            _current.run      = runs.size(); <span class="comment">// De facto next run id.</span></div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">            IOH_DBG(note, <span class="stringliteral">&quot;Attach to: pb=&quot;</span> &lt;&lt; _current.pb &lt;&lt; <span class="stringliteral">&quot;, dim=&quot;</span> &lt;&lt; _current.dim &lt;&lt; <span class="stringliteral">&quot;, ins=&quot;</span> &lt;&lt; _current.ins &lt;&lt; <span class="stringliteral">&quot;, run=&quot;</span> &lt;&lt; _current.run)</div>
<div class="line"><span class="preprocessor">#ifndef NDEBUG</span></div>
<div class="line">            <span class="keywordflow">if</span>(_has_problem_type and _current_problem_type.type() != problem.optimization_type.type()) {</div>
<div class="line">                IOH_DBG(warning, <span class="stringliteral">&quot;different types of problems are mixed, you will not be able to compute levels&quot;</span>)</div>
<div class="line">            }</div>
<div class="line"><span class="preprocessor">#endif</span></div>
<div class="line">            _current_problem_type = problem.optimization_type;</div>
<div class="line">            _has_problem_type = <span class="keyword">true</span>;</div>
<div class="line"><span class="preprocessor">#ifndef NDEBUG</span></div>
<div class="line">            <span class="keywordflow">if</span>(problem.optimization_type == common::OptimizationType::Minimization) {</div>
<div class="line">                _current_best =  std::numeric_limits&lt;double&gt;::infinity();</div>
<div class="line">            } <span class="keywordflow">else</span> {</div>
<div class="line">                _current_best = -std::numeric_limits&lt;double&gt;::infinity();</div>
<div class="line">            }</div>
<div class="line"><span class="preprocessor">#endif</span></div>
<div class="line">        }</div>
<div class="line"> </div>
<div class="line">        <span class="keywordtype">void</span> call(<span class="keyword">const</span> logger::Info&amp; log_info)<span class="keyword"> override</span></div>
<div class="line"><span class="keyword">        </span>{</div>
<div class="line">            IOH_DBG(debug, <span class="stringliteral">&quot;EAF called after improvement&quot;</span>)</div>
<div class="line">            <span class="comment">// Access the properties that were instantiated in the constructor.</span></div>
<div class="line">            const std::optional&lt;<span class="keywordtype">double</span>&gt; <a class="code" href="group___properties.html#gadfe2a79b8d1a64dc7583e2d4b2b07030">transformed_y_best</a> = properties_.<a class="code" href="group___triggers.html#gadc8aea7a9dfbe41f425b6c9fe993337c">at</a>(&quot;<a class="code" href="group___properties.html#gadfe2a79b8d1a64dc7583e2d4b2b07030">transformed_y_best</a>&quot;).get()(log_info);</div>
<div class="line">            const std::optional&lt;<span class="keywordtype">double</span>&gt; <a class="code" href="group___properties.html#gab6f329675f4deebd09b38e283de35ea7">evaluations</a>        = properties_.<a class="code" href="group___triggers.html#gadc8aea7a9dfbe41f425b6c9fe993337c">at</a>(&quot;<a class="code" href="group___properties.html#gab6f329675f4deebd09b38e283de35ea7">evaluations</a>&quot;).get()(log_info);</div>
<div class="line"><span class="preprocessor">#ifndef NDEBUG</span></div>
<div class="line">            assert(<a class="code" href="group___properties.html#gadfe2a79b8d1a64dc7583e2d4b2b07030">transformed_y_best</a>); <span class="comment">// Assert that the optional holds a value, which should be the case here.</span></div>
<div class="line">            assert(<a class="code" href="group___properties.html#gab6f329675f4deebd09b38e283de35ea7">evaluations</a>);</div>
<div class="line"> </div>
<div class="line">            <span class="comment">// If trigger::on_improvement does its job, we always have an improvement here.</span></div>
<div class="line">            assert(_current_problem_type(<a class="code" href="group___properties.html#gadfe2a79b8d1a64dc7583e2d4b2b07030">transformed_y_best</a>.value(),_current_best));</div>
<div class="line">            _current_best = <a class="code" href="group___properties.html#gadfe2a79b8d1a64dc7583e2d4b2b07030">transformed_y_best</a>.value();</div>
<div class="line"><span class="preprocessor">#endif</span></div>
<div class="line">            eaf::Front&amp; f = current_front();</div>
<div class="line">            f.push_back( eaf::RunPoint(</div>
<div class="line">                    <a class="code" href="group___properties.html#gadfe2a79b8d1a64dc7583e2d4b2b07030">transformed_y_best</a>.value(),</div>
<div class="line">                    <span class="keyword">static_cast&lt;</span><span class="keywordtype">size_t</span><span class="keyword">&gt;</span>(<a class="code" href="group___properties.html#gab6f329675f4deebd09b38e283de35ea7">evaluations</a>.value()),</div>
<div class="line">                    _current.run</div>
<div class="line">                ));</div>
<div class="line">        }</div>
<div class="line"> </div>
<div class="line">        <span class="keywordtype">void</span> reset()<span class="keyword"> override</span></div>
<div class="line"><span class="keyword">        </span>{</div>
<div class="line">            <a class="code" href="classioh_1_1_logger.html#a15ffee3436f277bdab243f219fb03d07">Logger::reset</a>();</div>
<div class="line">            IOH_DBG(note, <span class="stringliteral">&quot;reset&quot;</span>)</div>
<div class="line">        }</div>
<div class="line"> </div>
<div class="line">        <a class="code" href="namespaceioh_1_1common.html#a10ff539dd4ec41851f2c305aac9e3c4b">common::OptimizationType</a> optimization_type()<span class="keyword"> const</span></div>
<div class="line"><span class="keyword">        </span>{</div>
<div class="line">            assert(_has_problem_type);</div>
<div class="line">            <span class="keywordflow">return</span> _current_problem_type.type();</div>
<div class="line">        }</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">protected</span>:</div>
<div class="line"><span class="preprocessor">#ifndef NDEBUG</span></div>
<div class="line">        <span class="comment">// Use to double check that trigger::on_improvement do its job.</span></div>
<div class="line">        <span class="comment">// It should not be necessary otherwise.</span></div>
<div class="line">        <span class="keywordtype">double</span> _current_best;</div>
<div class="line"><span class="preprocessor">#endif</span></div>
<div class="line">        <span class="keywordtype">bool</span> _has_problem_type;</div>
<div class="line">        common::FOptimizationType _current_problem_type;</div>
<div class="line"> </div>
<div class="line">        Suites _data;</div>
<div class="line"> </div>
<div class="line">        Cursor _current;</div>
<div class="line"> </div>
<div class="line">        [[nodiscard]] eaf::Front&amp; current_front()</div>
<div class="line">        {</div>
<div class="line">            <span class="comment">// This creates maps if they do not exists.</span></div>
<div class="line">            <span class="keywordflow">return</span> _data[_current.suite][_current.pb][_current.dim][_current.ins][_current.run];</div>
<div class="line">        }</div>
<div class="line"> </div>
<div class="line">        trigger::OnImprovement _on_improvement;</div>
<div class="line"> </div>
<div class="line">        watch::Evaluations _evaluations;</div>
<div class="line"> </div>
<div class="line">        watch::TransformedYBest _transformed_y_best;</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">    }; <span class="comment">// class EAF</span></div>
<div class="line"> </div>
<div class="line">    <span class="keyword">namespace </span>eaf {</div>
<div class="line"> </div>
</div><!-- fragment --><p>From code: <a href="https://eden.dei.uc.pt/~cmfonsec/aft.html">https://eden.dei.uc.pt/~cmfonsec/aft.html</a> Related publication: </p><div class="fragment"><div class="line">@InProceedings{inp_Fonseca2011,</div>
<div class="line">  author     = {Fonseca, Carlos M. and Guerreiro, Andreia P. and López-Ibáñez, Manuel and Paquete, Luís},</div>
<div class="line">  booktitle  = {{I}nternational {C}onference on {E}volutionary {Multi}-{Criterion} {Optimization} ({EMO<span class="stringliteral">&#39;11}},</span></div>
<div class="line"><span class="stringliteral">  title      = {On the {Computation} of the {Empirical} {Attainment} {Function}},</span></div>
<div class="line"><span class="stringliteral">  year       = {2011},</span></div>
<div class="line"><span class="stringliteral">  address    = {Berlin, Heidelberg},</span></div>
<div class="line"><span class="stringliteral">  editor     = {Takahashi, Ricardo H. C. and Deb, Kalyanmoy and Wanner, Elizabeth F. and Greco, Salvatore},</span></div>
<div class="line"><span class="stringliteral">  pages      = {106--120},</span></div>
<div class="line"><span class="stringliteral">  publisher  = {Springer},</span></div>
<div class="line"><span class="stringliteral">  series     = {Lecture {Notes} in {Computer} {Science}},</span></div>
<div class="line"><span class="stringliteral">  abstract   = {The attainment function provides a description of the location of the distribution of a random non-dominated point set. This function can be estimated from experimental data via its empirical counterpart, the empirical attainment function (EAF). However, computation of the EAF in more than two dimensions is a non-trivial task. In this article, the problem of computing the empirical attainment function is formalised, and upper and lower bounds on the corresponding number of output points are presented. In addition, efficient algorithms for the two and three-dimensional cases are proposed, and their time complexities are related to lower bounds derived for each case.},</span></div>
<div class="line"><span class="stringliteral">  doi        = {10.1007/978-3-642-19893-9_8},</span></div>
<div class="line"><span class="stringliteral">  isbn       = {9783642198939},</span></div>
<div class="line"><span class="stringliteral">  language   = {en},</span></div>
<div class="line"><span class="stringliteral">}</span></div>
</div><!-- fragment --><p>From code: <a href="https://github.com/MLopez-Ibanez/eaf">https://github.com/MLopez-Ibanez/eaf</a> Related publication: </p><div class="fragment"><div class="line">@incollection{LopPaqStu09emaa,</div>
<div class="line">  editor = { Thomas Bartz-Beielstein  and  Marco Chiarandini  and  Lu{\<span class="stringliteral">&#39;\i}s Paquete  and  Mike Preuss },</span></div>
<div class="line"><span class="stringliteral">  year = 2010,</span></div>
<div class="line"><span class="stringliteral">  address = {Berlin, Germany},</span></div>
<div class="line"><span class="stringliteral">  publisher = {Springer},</span></div>
<div class="line"><span class="stringliteral">  booktitle = {Experimental Methods for the Analysis of Optimization Algorithms},</span></div>
<div class="line"><span class="stringliteral">  author = { Manuel L{\&#39;o}pez-Ib{\&#39;a}{\~n}ez  and  Lu{\&#39;\i}s Paquete  and  Thomas St{\&quot;u}tzle },</span></div>
<div class="line"><span class="stringliteral">  title = {Exploratory Analysis of Stochastic Local Search Algorithms in Biobjective Optimization},</span></div>
<div class="line"><span class="stringliteral">  pages = {209--222},</span></div>
<div class="line"><span class="stringliteral">  doi = {10.1007/978-3-642-02538-9_9},</span></div>
<div class="line"><span class="stringliteral">  abstract = {This chapter introduces two Perl programs that</span></div>
<div class="line"><span class="stringliteral">              implement graphical tools for exploring the performance of stochastic local search algorithms</span></div>
<div class="line"><span class="stringliteral">              for biobjective optimization problems. These tools are based on the concept of the empirical attainment</span></div>
<div class="line"><span class="stringliteral">              function (EAF), which describes the probabilistic distribution of the outcomes obtained by a</span></div>
<div class="line"><span class="stringliteral">              stochastic algorithm in the objective space. In particular, we consider the visualization of</span></div>
<div class="line"><span class="stringliteral">              attainment surfaces and differences between the first-order EAFs of the outcomes of two</span></div>
<div class="line"><span class="stringliteral">              algorithms. This visualization allows us to identify certain algorithmic behaviors in a graphical way.</span></div>
<div class="line"><span class="stringliteral">              We explain the use of these visualization tools and illustrate them with examples arising from</span></div>
<div class="line"><span class="stringliteral">              practice.}</span></div>
<div class="line"><span class="stringliteral">}</span></div>
</div><!-- fragment --> </div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a4d9d7b811e3dfa2054a2313a19590c34"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4d9d7b811e3dfa2054a2313a19590c34">&#9670;&nbsp;</a></span>Levels()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">ioh::logger::Levels::Levels </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceioh_1_1common.html#a10ff539dd4ec41851f2c305aac9e3c4b">common::OptimizationType</a>&#160;</td>
          <td class="paramname"><em>optim_type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; size_t &gt;&#160;</td>
          <td class="paramname"><em>attainment_levels</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructor. </p>
<p>Take the levelsets indices that you want to compute. There is as much attainment levelsets as there is runs in the logger, probably with duplicates. Indices should be in <code>[0,nb_runs[</code>.</p>
<p>If you pass an empty vector <code>{}</code> (the default), it will compute all the levelsets.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">optim_type</td><td>whether the problem is minimizing or maximizing. </td></tr>
    <tr><td class="paramname">attainment_levels</td><td>Levelsets to be computed (empty=all, the default). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="acaea09bd43bc3d493a4ca477a1e11dc7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acaea09bd43bc3d493a4ca477a1e11dc7">&#9670;&nbsp;</a></span>is_better()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool ioh::logger::Levels::is_better </td>
          <td>(</td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>q1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>q2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compare two objective function values. </p>
<p>Handle maximization or minimizaton problems transparently.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">q1</td><td>the considered objective value. </td></tr>
    <tr><td class="paramname">q2</td><td>the objective function value checked against. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if q1 is better than q2. </dd></dl>

</div>
</div>
<a id="aee07f212aaf68e27c4658e63afd123a1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aee07f212aaf68e27c4658e63afd123a1">&#9670;&nbsp;</a></span>is_better_or_eq()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool ioh::logger::Levels::is_better_or_eq </td>
          <td>(</td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>q1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>q2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compare two objective function values. </p>
<p>Handle maximization or minimizaton problems transparently.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">q1</td><td>the considered objective value. </td></tr>
    <tr><td class="paramname">q2</td><td>the objective function value checked against. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if q1 is better than or equal to q2. </dd></dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>ioh/logger/<a class="el" href="eaf_8hpp_source.html">eaf.hpp</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<div class="ttc" id="aclassioh_1_1_logger_html_a2be703d7bdcbdbfc636063a20d3eaa8e"><div class="ttname"><a href="classioh_1_1_logger.html#a2be703d7bdcbdbfc636063a20d3eaa8e">ioh::Logger::attach_problem</a></div><div class="ttdeci">virtual void attach_problem(const problem::MetaData &amp;problem)</div><div class="ttdoc">Starts a new session for the given problem/instance/dimension/run.</div><div class="ttdef"><b>Definition:</b> loggers.hpp:184</div></div>
<div class="ttc" id="agroup___properties_html_gab6f329675f4deebd09b38e283de35ea7"><div class="ttname"><a href="group___properties.html#gab6f329675f4deebd09b38e283de35ea7">ioh::watch::evaluations</a></div><div class="ttdeci">Evaluations evaluations</div><div class="ttdoc">Number of evaluations of the objective function called by the solver.</div><div class="ttdef"><b>Definition:</b> properties.hpp:152</div></div>
<div class="ttc" id="agroup___properties_html_gadfe2a79b8d1a64dc7583e2d4b2b07030"><div class="ttname"><a href="group___properties.html#gadfe2a79b8d1a64dc7583e2d4b2b07030">ioh::watch::transformed_y_best</a></div><div class="ttdeci">TransformedYBest transformed_y_best</div><div class="ttdoc">Best objective function value found so far, with transformation.</div><div class="ttdef"><b>Definition:</b> properties.hpp:243</div></div>
<div class="ttc" id="agroup___triggers_html_gadc8aea7a9dfbe41f425b6c9fe993337c"><div class="ttname"><a href="group___triggers.html#gadc8aea7a9dfbe41f425b6c9fe993337c">ioh::trigger::at</a></div><div class="ttdeci">At &amp; at(const std::set&lt; size_t &gt; time_points)</div><div class="ttdoc">Do log at the given number of evaluations.</div><div class="ttdef"><b>Definition:</b> triggers.hpp:437</div></div>
<div class="ttc" id="aclassioh_1_1_logger_html_a15ffee3436f277bdab243f219fb03d07"><div class="ttname"><a href="classioh_1_1_logger.html#a15ffee3436f277bdab243f219fb03d07">ioh::Logger::reset</a></div><div class="ttdeci">virtual void reset()</div><div class="ttdoc">Optional actions when the logger is detached from a suite/problem or the problem is reset.</div><div class="ttdef"><b>Definition:</b> loggers.hpp:202</div></div>
<div class="ttc" id="anamespaceioh_1_1common_html_a10ff539dd4ec41851f2c305aac9e3c4b"><div class="ttname"><a href="namespaceioh_1_1common.html#a10ff539dd4ec41851f2c305aac9e3c4b">ioh::common::OptimizationType</a></div><div class="ttdeci">OptimizationType</div><div class="ttdoc">Enum containing minimization = 0 and maximization = 1 flags.</div><div class="ttdef"><b>Definition:</b> optimization_type.hpp:11</div></div>
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><b>ioh</b></li><li class="navelem"><a class="el" href="namespaceioh_1_1logger.html">logger</a></li><li class="navelem"><a class="el" href="classioh_1_1logger_1_1_levels.html">Levels</a></li>
    <li class="footer">Generated on Sat Dec 18 2021 16:52:37 for IOH by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.17 </li>
  </ul>
</div>
</body>
</html>
